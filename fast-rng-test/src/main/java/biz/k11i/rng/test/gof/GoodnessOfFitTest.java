package biz.k11i.rng.test.gof;

import org.slf4j.Logger;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.function.Function;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Provides functionalities for Goodness-of-Fit test to test randomness of the given random number generator.
 */
@SuppressWarnings("unused")
public abstract class GoodnessOfFitTest {
    static class BuilderBase<SELF extends BuilderBase<SELF>> {
        @SuppressWarnings("unchecked")
        private final SELF self = (SELF) this;

        int numRandomValues;
        double significanceLevel = DEFAULT_SIGNIFICANCE_LEVEL;

        public SELF numRandomValues(int numRandomValues) {
            this.numRandomValues = numRandomValues;
            return self;
        }

        public SELF significanceLevel(double significanceLevel) {
            this.significanceLevel = significanceLevel;
            return self;
        }
    }

    /** Default significance level (0.1%) */
    private static final double DEFAULT_SIGNIFICANCE_LEVEL = 0.001;

    /** Name of the random number generator to be tested */
    public final String rngName;

    /** Significance level to reject the null hypothesis */
    public final double significanceLevel;

    GoodnessOfFitTest(String rngName, double significanceLevel) {
        this.rngName = rngName;
        this.significanceLevel = significanceLevel;
    }

    /**
     * Returns {@link ContinuousGofTest} builder object.
     *
     * @return builder object.
     */
    public static ContinuousGofTest.Builder continuous() {
        return new ContinuousGofTest.Builder();
    }

    /**
     * Returns {@link DiscreteGofTest} builder object.
     *
     * @return builder obbject.
     */
    public static DiscreteGofTest.Builder discrete() {
        return new DiscreteGofTest.Builder();
    }

    /**
     * Calculate p-values of Goodness-of-Fit test.
     *
     * @return test result.
     */
    public abstract Map<String, Double> test();

    /**
     * Calculate p-values of Goodness-of-Fit test in parallel.
     *
     * @return test result.
     */
    public Map<String, Double> testInParallel() {
        ForkJoinPool pool = new ForkJoinPool();
        try {
            return testInParallel(pool);

        } finally {
            pool.shutdown();
            try {
                pool.awaitTermination(1, TimeUnit.SECONDS);
            } catch (InterruptedException ignore) {
            }
        }
    }

    /**
     * Calculate p-values of Goodness-of-Fit test in parallel using given {@link ForkJoinPool} instance.
     *
     * @param pool Fork/Join pool to execute tasks in paralle.
     * @return test result.
     */
    public abstract Map<String, Double> testInParallel(ForkJoinPool pool);

    /**
     * Runs Goodness-of-Fit tests and verifis whether the test failed to reject the null hypothesis
     * (which means the random sequence that was generated by random number generator can be described as random) or not.
     */
    public void testAndVerify() {
        Map<String, Double> result = test();

        result.forEach((t, p) ->
                assertThat(p)
                        .describedAs("At a significance level of %e, the Goodness-of-Fit test of [%s] should fail to reject null hypothesis (The p-value %f should be greater than or equal to %e).\n" +
                                        "This means that the random sequence generated by the random number generator [%s] fit the theoretical probability distribution.",
                                significanceLevel, t, p, significanceLevel,
                                rngName)
                        .isGreaterThanOrEqualTo(significanceLevel));
    }
}

@SuppressWarnings("unused")
class PerformanceMeasure {
    static class LogRecord {
        private final String message;
        private Object[] args;
        private final long beginMillis = System.currentTimeMillis();
        private long endMillis;

        LogRecord(String message) {
            this.message = message;
        }

        void updateArgs(Object... args) {
            this.args = args;
        }

        long elapsedMillis() {
            return endMillis - beginMillis;
        }
    }

    private final List<LogRecord> bufferedLogs = new ArrayList<>();

    static <T> T run(Logger logger, Function<PerformanceMeasure, T> process) {
        PerformanceMeasure m = new PerformanceMeasure();
        try {
            return process.apply(m);
        } finally {
            m.flushLogs(logger);
        }
    }

    void measure(String logMessageTemplate, Consumer<LogRecord> processToMeasure) {
        measure(logMessageTemplate, args(), processToMeasure);
    }

    void measure(String logMessageTemplate, Object arg1, Consumer<LogRecord> processToMeasure) {
        measure(logMessageTemplate, args(arg1), processToMeasure);
    }

    void measure(String logMessageTemplate, Object arg1, Object arg2, Consumer<LogRecord> processToMeasure) {
        measure(logMessageTemplate, args(arg1, arg2), processToMeasure);
    }

    void measure(String logMessageTemplate, Object[] args, Consumer<LogRecord> processToMeasure) {
        long begin = System.currentTimeMillis();

        LogRecord logRecord = new LogRecord(logMessageTemplate);
        logRecord.args = args;
        bufferedLogs.add(logRecord);

        processToMeasure.accept(logRecord);
        logRecord.endMillis = System.currentTimeMillis();
    }

    Object[] args(Object... args) {
        return args;
    }

    private void flushLogs(Logger logger) {
        bufferedLogs.sort(Comparator.comparingLong(o -> o.beginMillis));

        for (LogRecord log : bufferedLogs) {
            Object[] args = Arrays.copyOf(log.args, log.args.length + 1);
            args[log.args.length] = log.elapsedMillis();
            logger.info(log.message + " ({} ms)", args);
        }
    }
}
